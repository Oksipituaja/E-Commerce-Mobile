var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs-extra", "path", "../../utils", "@clack/prompts", "os"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.componentAdder = void 0;
    const fs_extra_1 = __importDefault(require("fs-extra"));
    const path_1 = __importDefault(require("path"));
    const utils_1 = require("../../utils");
    const prompts_1 = require("@clack/prompts");
    const os_1 = __importDefault(require("os"));
    const prompts = require('prompts');
    const rootPackageJsonPath = (0, utils_1.getPackageJsonPath)();
    const homeDir = os_1.default.homedir();
    let existingComponentsChecked = false;
    const currDir = process.cwd();
    const getComponentsList = () => __awaiter(void 0, void 0, void 0, function* () {
        const sourcePath = path_1.default.join(homeDir, '.gluestack', 'cache', 'gluestack-ui', 'example', 'storybook', 'src', 'ui-components');
        return fs_extra_1.default.readdirSync(sourcePath);
    });
    const checkIfComponentIsValid = (component) => __awaiter(void 0, void 0, void 0, function* () {
        const componentList = yield getComponentsList();
        if (componentList.includes(component) ||
            componentList.includes((0, utils_1.dashToPascal)(component))) {
            return true;
        }
        return false;
    });
    const componentAdder = (...args_1) => __awaiter(void 0, [...args_1], void 0, function* (requestedComponent = '', showWarning = true, isUpdate = false, forceUpdate = false) {
        if (!(yield checkIfComponentIsValid(requestedComponent)) &&
            requestedComponent !== '--all' &&
            requestedComponent !== '') {
            prompts_1.log.error('\x1b[32m' +
                `The ${requestedComponent} does not exists. Kindly choose from the below list.` +
                '\x1b[0m');
        }
        try {
            // Get config
            const sourcePath = path_1.default.join(homeDir, '.gluestack', 'cache', 'gluestack-ui', 'example', 'storybook', 'src', 'ui-components');
            let requestedComponents = [];
            let addComponents = [];
            if (requestedComponent === '--all') {
                requestedComponents = getAllComponents(sourcePath);
            }
            else {
                requestedComponents.push(requestedComponent);
            }
            if (!existingComponentsChecked &&
                showWarning &&
                requestedComponent !== '' &&
                !forceUpdate) {
                const updatedComponents = yield checkForExistingFolders(requestedComponents);
                addComponents = [...updatedComponents];
            }
            else {
                addComponents = requestedComponents;
            }
            yield Promise.all(addComponents.map((component) => __awaiter(void 0, void 0, void 0, function* () {
                const componentPath = (0, utils_1.getConfigComponentPath)();
                // createFolders(path.join(currDir, componentPath));
                const targetPath = path_1.default.join(currDir, componentPath);
                yield copyFolders(sourcePath, targetPath, component, isUpdate, forceUpdate);
                (0, utils_1.addIndexFile)(targetPath);
            })));
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    exports.componentAdder = componentAdder;
    const copyFolders = (sourcePath_1, targetPath_1, specificComponent_1, isUpdate_1, ...args_1) => __awaiter(void 0, [sourcePath_1, targetPath_1, specificComponent_1, isUpdate_1, ...args_1], void 0, function* (sourcePath, targetPath, specificComponent, isUpdate, forceUpdate = false) {
        const groupedComponents = {};
        let specificComponentType;
        //  Traverse all components
        try {
            fs_extra_1.default.readdirSync(sourcePath).forEach((component) => {
                if (component !== 'index.ts' &&
                    component !== 'index.tsx' &&
                    component !== 'Provider') {
                    // Read in the existing package.json file
                    const packageJsonPath = path_1.default.join(sourcePath, component, 'config.json');
                    const packageJson = JSON.parse(fs_extra_1.default.readFileSync(packageJsonPath, 'utf8'));
                    let componentType;
                    if (packageJson.keywords.indexOf('components') !== -1) {
                        componentType = packageJson.keywords[1];
                    }
                    if (componentType) {
                        const cliComponent = (0, utils_1.pascalToDash)(component);
                        groupedComponents[componentType] =
                            groupedComponents[componentType] || [];
                        groupedComponents[componentType].push(cliComponent);
                    }
                    const sourceComponent = (0, utils_1.pascalToDash)(component);
                    if (sourceComponent.toLowerCase() === specificComponent.toLowerCase()) {
                        specificComponentType = componentType;
                    }
                }
            });
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
            return;
        }
        let selectedComponents = [];
        // Ask component type
        if (!specificComponentType) {
            let selectedComponentType = [];
            while (selectedComponentType.length === 0) {
                const selectedComponent = yield prompts([
                    {
                        type: 'multiselect',
                        name: 'value',
                        message: 'Select the type of components:',
                        choices: Object.keys(groupedComponents).map(type => {
                            return { value: type, title: type };
                        }),
                        validate: (value) => value.length > 0,
                        instructions: false,
                    },
                ]);
                selectedComponentType = selectedComponent.value;
            }
            if ((0, prompts_1.isCancel)(selectedComponentType)) {
                (0, prompts_1.cancel)('Operation cancelled.');
                process.exit(0);
            }
            if (Array.isArray(selectedComponentType)) {
                yield Promise.all(selectedComponentType.map((component) => __awaiter(void 0, void 0, void 0, function* () {
                    if (groupedComponents[component].length !== 0) {
                        const selectComponents = yield prompts([
                            {
                                type: 'multiselect',
                                name: 'value',
                                message: 'Select the type of components:',
                                choices: groupedComponents[component].map(type => {
                                    return { title: type, value: type };
                                }),
                                instructions: false,
                            },
                        ]);
                        const selectComponentsValue = selectComponents.value;
                        // const selectComponents = await multiselect({
                        //   message: `Select ${component} components:`,
                        //   options: groupedComponents[component].map((type) => {
                        //     return { value: type, label: type };
                        //   }),
                        //   required: true,
                        // });
                        if ((0, prompts_1.isCancel)(selectComponentsValue)) {
                            (0, prompts_1.cancel)('Operation cancelled.');
                            process.exit(0);
                        }
                        selectedComponents[component] = selectComponentsValue;
                    }
                    else {
                        prompts_1.log.error(`\x1b[31mError: No components of ${component} type!\x1b[0m`);
                    }
                })));
            }
        }
        else {
            selectedComponents[specificComponentType] = [specificComponent];
        }
        yield Promise.all(Object.keys(selectedComponents).map(component => {
            // createFolders(path.join(targetPath, component));
            selectedComponents[component].map((subcomponent) => {
                // Add Packages
                const originalComponentPath = (0, utils_1.dashToPascal)(subcomponent);
                const compPackageJsonPath = path_1.default.join(sourcePath, originalComponentPath, 'config.json');
                const compPackageJson = JSON.parse(fs_extra_1.default.readFileSync(compPackageJsonPath, 'utf8'));
                if (compPackageJson.componentDependencies &&
                    compPackageJson.componentDependencies.length > 0) {
                    compPackageJson.componentDependencies.map((component) => __awaiter(void 0, void 0, void 0, function* () {
                        yield componentAdder(component, false, true, forceUpdate);
                    }));
                }
                const rootPackageJson = JSON.parse(fs_extra_1.default.readFileSync(rootPackageJsonPath, 'utf8'));
                rootPackageJson.dependencies = Object.assign(Object.assign({}, rootPackageJson.dependencies), compPackageJson.dependencies);
                fs_extra_1.default.writeFileSync(rootPackageJsonPath, JSON.stringify(rootPackageJson, null, 2));
                // createFolders(path.join(targetPath, component, originalComponentPath));
                fs_extra_1.default.copySync(path_1.default.join(sourcePath, originalComponentPath), path_1.default.join(targetPath, component, originalComponentPath));
                if (fs_extra_1.default.existsSync(path_1.default.join(targetPath, component, originalComponentPath, 'config.json'))) {
                    fs_extra_1.default.unlinkSync(path_1.default.join(targetPath, component, originalComponentPath, 'config.json'));
                }
                if (!isUpdate) {
                    prompts_1.log.success(`\x1b[32m✅  ${'\u001b[1m' +
                        originalComponentPath +
                        '\u001b[22m'} \x1b[0m component added successfully!`);
                }
                else {
                    prompts_1.log.success(`\x1b[32m✅  ${'\u001b[1m' +
                        originalComponentPath +
                        '\u001b[22m'} \x1b[0m component updated successfully!`);
                }
            });
        }));
    });
    const checkForExistingFolders = (specificComponents) => __awaiter(void 0, void 0, void 0, function* () {
        const alreadyExistingComponents = [];
        let selectedComponents = [];
        for (const component of specificComponents) {
            const componentPath = (0, utils_1.getConfigComponentPath)();
            const pathToCheck = path_1.default.join(currDir, componentPath, 'core', (0, utils_1.dashToPascal)(component));
            if (fs_extra_1.default.existsSync(pathToCheck)) {
                alreadyExistingComponents.push(component);
            }
        }
        if (alreadyExistingComponents.length === 1) {
            const shouldContinue = yield (0, prompts_1.confirm)({
                message: `The ${alreadyExistingComponents[0]} component already exists. Kindly proceed if you wish to replace. Be advised that if there are any interdependent components, proceeding will result in their dependent components being replaced as well.`,
            });
            if ((0, prompts_1.isCancel)(shouldContinue)) {
                (0, prompts_1.cancel)('Operation cancelled.');
                process.exit(0);
            }
            if (shouldContinue) {
                selectedComponents = alreadyExistingComponents;
            }
        }
        else if (alreadyExistingComponents.length > 0) {
            const selectComponentsValue = yield prompts([
                {
                    type: 'multiselect',
                    name: 'value',
                    message: `The following components already exists. Kindly choose the ones you wish to replace. Be advised that if there are any interdependent components, selecting them for replacement will result in their dependent components being replaced as well.`,
                    choices: alreadyExistingComponents.map(component => ({
                        title: component,
                        value: component,
                    })),
                    instructions: false,
                },
            ]);
            selectedComponents = selectComponentsValue.value;
            if ((0, prompts_1.isCancel)(selectedComponents)) {
                (0, prompts_1.cancel)('Operation cancelled.');
                process.exit(0);
            }
        }
        // Remove repeated components from all components
        const filteredComponents = specificComponents.filter(component => !alreadyExistingComponents.includes(component));
        // Add selected components to all components
        const updatedComponents = filteredComponents.concat(selectedComponents);
        existingComponentsChecked = true;
        return updatedComponents;
    });
    const getAllComponents = (source) => {
        const requestedComponents = [];
        fs_extra_1.default.readdirSync(source).forEach((component) => {
            if (!(component === 'index.ts' ||
                component === 'index.tsx' ||
                component === 'Provider')) {
                const packageJsonPath = path_1.default.join(source, component, 'config.json');
                const packageJson = JSON.parse(fs_extra_1.default.readFileSync(packageJsonPath, 'utf8'));
                let componentType;
                if (packageJson.keywords.indexOf('components') !== -1) {
                    componentType = packageJson.keywords[1];
                }
                if (componentType) {
                    const cliComponent = (0, utils_1.pascalToDash)(component);
                    requestedComponents.push(cliComponent);
                }
            }
        });
        return requestedComponents;
    };
});
