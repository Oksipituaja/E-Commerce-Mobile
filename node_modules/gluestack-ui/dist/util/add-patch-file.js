var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "path", "@clack/prompts"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupReactNativeWebPatch = setupReactNativeWebPatch;
    exports.validatePatchFile = validatePatchFile;
    const fs_1 = __importDefault(require("fs"));
    const path_1 = __importDefault(require("path"));
    const prompts_1 = require("@clack/prompts");
    /**
     * Sets up the patch file for react-native-web in the patches directory
     * @param projectPath - Root path of the project
     * @param templatePath - Path to the scripts/template directory
     * @returns Promise with the result of the operation
     */
    function setupReactNativeWebPatch() {
        return __awaiter(this, arguments, void 0, function* (projectPath = process.cwd()) {
            try {
                // Define paths
                const templatePath = path_1.default.join(__dirname, '..', '..', 'template', 'nextjs', 'next15');
                const patchesDir = path_1.default.join(projectPath, 'patches');
                const patchFileName = 'react-native-web+0.19.13.patch';
                const sourcePatchPath = path_1.default.join(templatePath, patchFileName);
                const targetPatchPath = path_1.default.join(patchesDir, patchFileName);
                // Check if template patch file exists
                if (!fs_1.default.existsSync(sourcePatchPath)) {
                    prompts_1.log.error(`Template patch file not found at: ${sourcePatchPath}`);
                    return false;
                }
                // Create patches directory if it doesn't exist
                if (!fs_1.default.existsSync(patchesDir)) {
                    fs_1.default.mkdirSync(patchesDir, { recursive: true });
                }
                // Copy patch file if it doesn't exist or force update
                if (!fs_1.default.existsSync(targetPatchPath)) {
                    fs_1.default.copyFileSync(sourcePatchPath, targetPatchPath);
                }
                else {
                    // Compare files to see if they're different
                    const sourceContent = fs_1.default.readFileSync(sourcePatchPath, 'utf8');
                    const targetContent = fs_1.default.readFileSync(targetPatchPath, 'utf8');
                    if (sourceContent !== targetContent) {
                        // Backup existing file
                        const backupPath = `${targetPatchPath}.backup`;
                        fs_1.default.copyFileSync(targetPatchPath, backupPath);
                        // Update patch file
                        fs_1.default.copyFileSync(sourcePatchPath, targetPatchPath);
                    }
                }
                return true;
            }
            catch (error) {
                prompts_1.log.error(error instanceof Error ? error.message : 'Unknown error occurred');
                return false;
            }
        });
    }
    /**
     * Validates the patch file setup
     * @param patchPath - Path to the patch file
     * @returns boolean indicating if patch file is valid
     */
    function validatePatchFile(patchPath) {
        try {
            if (!fs_1.default.existsSync(patchPath)) {
                return false;
            }
            const content = fs_1.default.readFileSync(patchPath, 'utf8');
            // Basic validation - check if it looks like a patch file
            return content.includes('diff --git') || content.includes('@@');
        }
        catch (_a) {
            return false;
        }
    }
});
