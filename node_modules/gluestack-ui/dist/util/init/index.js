var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "os", "../../config", "util", "child_process", "path", "@clack/prompts", "fs-extra", "../config", "..", "../../dependencies", "../config/next-config-helper", "../config/expo-config-helper", "../config/react-native-config-helper", "../check-next-version", "fs-extra"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InitializeGlueStack = void 0;
    exports.commonInitialization = commonInitialization;
    const os_1 = __importDefault(require("os"));
    const config_1 = require("../../config");
    const util_1 = require("util");
    const child_process_1 = require("child_process");
    const path_1 = __importStar(require("path"));
    const prompts_1 = require("@clack/prompts");
    const fs_extra_1 = __importStar(require("fs-extra"));
    const config_2 = require("../config");
    const __1 = require("..");
    const dependencies_1 = require("../../dependencies");
    const next_config_helper_1 = require("../config/next-config-helper");
    const expo_config_helper_1 = require("../config/expo-config-helper");
    const react_native_config_helper_1 = require("../config/react-native-config-helper");
    const check_next_version_1 = require("../check-next-version");
    const fs_extra_2 = require("fs-extra");
    const _currDir = process.cwd();
    const _homeDir = os_1.default.homedir();
    const readFileAsync = (0, util_1.promisify)(fs_extra_1.default.readFile);
    const writeFileAsync = (0, util_1.promisify)(fs_extra_1.default.writeFile);
    const InitializeGlueStack = (_a) => __awaiter(void 0, [_a], void 0, function* ({ projectType = 'library', isTemplate = false, alpha, }) {
        try {
            const initializeStatus = yield (0, config_2.checkIfInitialized)(_currDir);
            if (initializeStatus) {
                prompts_1.log.info(`\x1b[33mgluestack-ui is already initialized in the project, use 'npx gluestack-ui help' command to continue\x1b[0m`);
                process.exit(1);
            }
            const isNextjs15 = yield (0, check_next_version_1.checkNextVersion)();
            const confirmOverride = isTemplate
                ? true
                : yield overrideWarning(filesToOverride(projectType));
            console.log(`\n\x1b[1mInitializing gluestack-ui v2...\x1b[0m\n`);
            yield (0, __1.cloneRepositoryAtRoot)((0, path_1.join)(_homeDir, config_1.config.gluestackDir), alpha);
            const inputComponent = [config_1.config.providerComponent];
            let additionalDependencies = yield (0, dependencies_1.getProjectBasedDependencies)(projectType, config_1.config.style);
            if (isNextjs15) {
                additionalDependencies = Object.assign(Object.assign({}, additionalDependencies), { devDependencies: Object.assign(Object.assign({}, additionalDependencies === null || additionalDependencies === void 0 ? void 0 : additionalDependencies.devDependencies), { 'patch-package': 'latest' }) });
            }
            let versionManager = (0, __1.findLockFileType)();
            if (!versionManager) {
                versionManager = yield (0, __1.promptVersionManager)();
            }
            yield (0, __1.installDependencies)(inputComponent, versionManager, additionalDependencies);
            const s = (0, prompts_1.spinner)();
            s.start('⏳ Generating project configuration. This might take a couple of minutes...');
            yield generateProjectConfigAndInit(projectType, confirmOverride, isNextjs15);
            yield addProvider(isNextjs15);
            if (isNextjs15) {
                (0, child_process_1.execSync)(`${versionManager} run postinstall`);
            }
            s.stop(`\x1b[32mProject configuration generated.\x1b[0m`);
            prompts_1.log.step('Please refer the above link for more details --> \x1b[33mhttps://gluestack.io/ui/docs/home/overview/introduction \x1b[0m');
            prompts_1.log.success(`\x1b[32mDone!\x1b[0m Initialized \x1b[1mgluestack-ui v2\x1b[0m in the project`);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError occured in init. (${err})\x1b[0m`);
            process.exit(1);
        }
    });
    exports.InitializeGlueStack = InitializeGlueStack;
    function addProvider(isNextjs15) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const targetPath = (0, path_1.join)(_currDir, config_1.config.writableComponentsPath, config_1.config.providerComponent);
                const sourcePath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, config_1.config.style, config_1.config.providerComponent);
                yield fs_extra_1.default.ensureDir(targetPath);
                yield fs_extra_1.default.copy(sourcePath, targetPath);
                if (isNextjs15) {
                    const providerContent = yield (0, fs_extra_2.readFile)((0, path_1.join)(__dirname, `${config_1.config.templatesDir}`, 'nextjs', 'next15', 'index.web.tsx'), 'utf8');
                    yield (0, fs_extra_1.writeFile)((0, path_1.join)(targetPath, 'index.web.tsx'), providerContent, 'utf8');
                }
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError occured while adding the provider.\x1b[0m`);
                throw new Error(err.message);
            }
        });
    }
    //update tailwind.config.js and codemod
    function updateTailwindConfig(resolvedConfig, projectType) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create a temporary file to store options
            const tempFilePath = (0, path_1.join)(os_1.default.tmpdir(), 'jscodeshift-options.json');
            try {
                const tailwindConfigRootPath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.tailwindConfigRootPath);
                const tailwindConfigPath = resolvedConfig.tailwind.config;
                yield fs_extra_1.default.copy(tailwindConfigRootPath, tailwindConfigPath);
                // Codemod to update tailwind.config.js usage
                const { entryPath } = (0, config_2.getEntryPathAndComponentsPath)(); // entryPaths is an array of strings
                fs_extra_1.default.writeFileSync(tempFilePath, JSON.stringify({ paths: entryPath }) // Write paths and projectType to the file
                );
                const transformerPath = (0, path_1.join)(__dirname, `${config_1.config.codeModesDir}/tailwind-config-transform.ts`);
                // Build the jscodeshift command
                const command = `npx jscodeshift -t ${transformerPath} ${tailwindConfigPath} --optionsFile=${tempFilePath} --projectType=${projectType}`;
                // Execute the command
                (0, child_process_1.execSync)(command);
                // Delete the temporary file after usage
                fs_extra_1.default.unlinkSync(tempFilePath);
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err}\x1b[0m`);
                // Ensure the temporary file is deleted even in case of an error
                if (fs_extra_1.default.existsSync(tempFilePath)) {
                    fs_extra_1.default.unlinkSync(tempFilePath);
                }
            }
        });
    }
    //updateConfig helper, create default tsconfig.json
    function createDefaultTSConfig() {
        return {
            compilerOptions: {
                paths: {
                    '@/*': ['./*'],
                },
            },
            exclude: ['node_modules'],
        };
    }
    // updateConfig helper, read tsconfig.json
    function readTSConfig(configPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return JSON.parse(yield readFileAsync(configPath, 'utf8'));
            }
            catch (_a) {
                return createDefaultTSConfig();
            }
        });
    }
    // updateConfig helper, update paths in tsconfig.json
    function updatePaths(paths, key, newValues) {
        paths[key] = Array.from(new Set([...(paths[key] || []), ...newValues]));
    }
    //update tsconfig.json
    function updateTSConfig(projectType, resolvedConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const configPath = resolvedConfig.config.tsConfig;
                let tsConfig = yield readTSConfig(configPath);
                let tailwindConfig = resolvedConfig.tailwind.config;
                const tailwindConfigFileName = path_1.default.basename(tailwindConfig);
                tsConfig.compilerOptions = tsConfig.compilerOptions || {};
                tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
                // Next.js project specific configuration
                if (projectType === config_1.config.nextJsProject) {
                    tsConfig.compilerOptions.jsxImportSource = 'nativewind';
                }
                updatePaths(tsConfig.compilerOptions.paths, '@/*', ['./*']);
                updatePaths(tsConfig.compilerOptions.paths, 'tailwind.config', [
                    `./${tailwindConfigFileName}`,
                ]);
                yield writeFileAsync(configPath, JSON.stringify(tsConfig, null, 2), 'utf8');
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError occurred while updating tsconfig.json: ${err.message}\x1b[0m`);
            }
        });
    }
    //update global.css
    function updateGlobalCss(resolvedConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const globalCSSPath = resolvedConfig.tailwind.css;
                const globalCSSContent = yield fs_extra_1.default.readFile((0, path_1.join)(__dirname, config_1.config.templatesDir, 'common', 'global.css'), 'utf8');
                const existingContent = yield fs_extra_1.default.readFile(globalCSSPath, 'utf8');
                if (existingContent.includes(globalCSSContent)) {
                    return;
                }
                else {
                    yield fs_extra_1.default.appendFile(globalCSSPath, globalCSSContent.toString(), // Convert buffer to string
                    'utf8');
                }
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err}\x1b[0m`);
            }
        });
    }
    function commonInitialization(projectType, resolvedConfig, permission) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                //get resolvedFileNames from the resolvedConfig
                const resolvedConfigValues = Object.values(resolvedConfig).flat(Infinity);
                const flattenedConfigValues = resolvedConfigValues.flatMap((value) => typeof value === 'string' ? value : Object.values(value));
                const resolvedConfigFileNames = flattenedConfigValues.map((filePath) => typeof filePath === 'string' && path_1.default.parse(filePath).base);
                const resourcePath = (0, path_1.join)(__dirname, config_1.config.templatesDir, projectType);
                //if any filepath
                if ((0, fs_extra_1.existsSync)(resourcePath)) {
                    const filesAndFolders = fs_extra_1.default.readdirSync(resourcePath);
                    //if any fileName in resourcePath matches with the resolvedConfigFileNames, copy the file
                    yield Promise.all(filesAndFolders.map((file) => __awaiter(this, void 0, void 0, function* () {
                        if (resolvedConfigFileNames.includes(path_1.default.parse(file).base)) {
                            yield (0, fs_extra_1.copy)((0, path_1.join)(resourcePath, file), (0, path_1.join)(_currDir, file), {
                                overwrite: true,
                            });
                        }
                    })));
                }
                //add nativewind-env.d.ts contents
                yield fs_extra_1.default.copy((0, path_1.join)(__dirname, config_1.config.templatesDir, 'common', 'nativewind-env.d.ts'), (0, path_1.join)(_currDir, 'nativewind-env.d.ts'));
                permission && (yield updateTSConfig(projectType, resolvedConfig));
                permission && (yield updateGlobalCss(resolvedConfig));
                yield updateTailwindConfig(resolvedConfig, projectType);
                //function to update package.json script to implement darkMode in expo, will be removed later
                if (projectType === config_1.config.expoProject) {
                    const packageJsonPath = (0, path_1.join)(_currDir, 'package.json');
                    const packageJson = JSON.parse(yield fs_extra_1.default.readFile(packageJsonPath, 'utf8'));
                    const devices = ['android', 'ios', 'web'];
                    //get existing value of scripts
                    devices.forEach((device) => {
                        const script = packageJson.scripts[device];
                        packageJson.scripts[device] = `DARK_MODE=media `.concat(script);
                    });
                    yield fs_extra_1.default.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), 'utf8');
                }
            }
            catch (err) {
                throw new Error(err.message);
            }
        });
    }
    //generate project config and initialize
    function generateProjectConfigAndInit(projectType, confirmOverride, isNextjs15) {
        return __awaiter(this, void 0, void 0, function* () {
            let permission;
            if (confirmOverride === false || typeof confirmOverride === 'symbol') {
                permission = false;
            }
            else
                permission = true;
            let resolvedConfig; // Initialize with a default value
            if (projectType !== 'library') {
                switch (projectType) {
                    case config_1.config.nextJsProject:
                        yield (0, next_config_helper_1.generateConfigNextApp)(permission, isNextjs15);
                        break;
                    case config_1.config.expoProject:
                        yield (0, expo_config_helper_1.generateConfigExpoApp)(permission);
                        break;
                    case config_1.config.reactNativeCLIProject:
                        yield (0, react_native_config_helper_1.generateConfigRNApp)(permission);
                        break;
                    default:
                        break;
                }
            }
            else {
                //write function to generate config for monorepo or library
                yield (0, config_2.generateMonoRepoConfig)();
            }
            return resolvedConfig;
        });
    }
    //files to override in the project directory data
    const filesToOverride = (projectType) => {
        switch (projectType) {
            case config_1.config.nextJsProject:
                return [
                    'next.config.*',
                    'tailwind.config.*',
                    'global.css',
                    'tsconfig.json',
                ];
            case config_1.config.expoProject:
                return [
                    'babel.config.js',
                    'metro.config.js',
                    'tailwind.config.*',
                    'global.css',
                    'tsconfig.json',
                ];
            case config_1.config.reactNativeCLIProject:
                return [
                    'babel.config.js',
                    'metro.config.js',
                    'global.css',
                    'tsconfig.json',
                ];
            default:
                return [];
        }
    };
    // Helper function to calculate the length of the string without ANSI escape codes
    function getStringLengthWithoutAnsi(string) {
        return string.replace(/\x1b\[[0-9;]*m/g, '').length;
    }
    //overriding warning message
    function overrideWarning(files) {
        return __awaiter(this, void 0, void 0, function* () {
            if (files.length === 0) {
                return true;
            }
            const boxLength = 90;
            console.log(`\x1b[33m
  ┌${'─'.repeat(boxLength)}┐
  │                                                                                          │
  │  NOTE: Files to get modified                                                             │
  │                                                                                          │
  │  The command you've run is attempting to modify certain files in your project,           │
  │  if already exist. Here's what's happening:                                              │
  │                                                                                          │
${files
                .map((file) => `  │  - ${file}${' '.repeat(boxLength - getStringLengthWithoutAnsi(`  │  - ${file}`) + 3)}│`)
                .join('\n')}
  │                                                                                          │
  └${'─'.repeat(boxLength)}┘
  \x1b[0m`);
            const confirmInput = yield (0, prompts_1.confirm)({
                message: `\x1b[33mProceed with caution. Make sure to commit your changes before proceeding. Continue?
    \x1b[0m`,
            });
            if (confirmInput === false) {
                prompts_1.log.info('Skipping making changes in files. Please refer docs for making the changes manually --> \x1b[33mhttps://gluestack.io/ui/docs/home/getting-started/installation\x1b[0m');
            }
            return confirmInput;
        });
    }
});
