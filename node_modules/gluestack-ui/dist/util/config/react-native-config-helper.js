var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", ".", "..", "../../config", "path", "child_process", "os", "../init"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateConfigRNApp = generateConfigRNApp;
    const _1 = require(".");
    const __1 = require("..");
    const config_1 = require("../../config");
    const path_1 = require("path");
    const child_process_1 = require("child_process");
    const os_1 = __importDefault(require("os"));
    const init_1 = require("../init");
    //react-native project type initialization
    function resolvedReactNativePaths(resultConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedReactNativePaths = {
                tailwind: {
                    config: (0, _1.pathResolver)(resultConfig.tailwind.config),
                    css: (0, _1.pathResolver)(resultConfig.tailwind.css),
                },
                config: {
                    babelConfig: (0, _1.pathResolver)(resultConfig.config.babelConfig || ''),
                    metroConfig: (0, _1.pathResolver)(resultConfig.config.metroConfig || ''),
                    tsConfig: (0, _1.pathResolver)(resultConfig.config.tsConfig || ''),
                },
                app: {
                    entry: (0, _1.pathResolver)(resultConfig.app.entry || ''),
                },
            };
            return resolvedReactNativePaths;
        });
    }
    const podInstall = () => __awaiter(void 0, void 0, void 0, function* () {
        const platform = os_1.default.platform();
        if (platform === 'darwin') {
            // macOS
            (0, child_process_1.execSync)('npx pod-install', { stdio: 'inherit' });
        }
    });
    //project specific initialization: react-native
    function initNatiwindRNApp(resolvedConfig, permission) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const relativeCSSImport = (0, __1.getRelativePath)({
                    sourcePath: resolvedConfig.app.entry,
                    targetPath: resolvedConfig.tailwind.css,
                });
                const RNTransformer = (0, path_1.join)(__dirname, config_1.config.codeModesDir, config_1.config.reactNativeCLIProject);
                const BabelTransformerPath = (0, path_1.join)(RNTransformer, `babel-config-transform.ts`);
                const metroTransformerPath = (0, path_1.join)(RNTransformer, `metro-config-transform.ts`);
                const addProviderTransformerPath = (0, path_1.join)(RNTransformer, 'rn-add-provider-transform.ts');
                (0, child_process_1.execSync)(`npx jscodeshift -t ${BabelTransformerPath}  ${resolvedConfig.config.babelConfig} --tailwindConfigPath=${resolvedConfig.tailwind.config}`);
                (0, child_process_1.execSync)(`npx jscodeshift -t ${metroTransformerPath}  ${resolvedConfig.config.metroConfig}`);
                (0, child_process_1.execSync)(`npx  jscodeshift -t ${addProviderTransformerPath} ${resolvedConfig.app.entry}  --componentsPath='${config_1.config.writableComponentsPath}' --cssImportPath='${relativeCSSImport}'`);
                yield (0, init_1.commonInitialization)(config_1.config.reactNativeCLIProject, resolvedConfig, permission);
                yield podInstall();
            }
            catch (err) {
                throw new Error(err.message);
            }
        });
    }
    function generateConfigRNApp(permission) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPath = yield (0, _1.getFilePath)(['**/*App.*']);
            const globalCssPath = yield (0, _1.getFilePath)([
                '**/*globals.css',
                '**/*global.css',
            ]);
            const tailwindConfigPath = yield (0, _1.getFilePath)(['tailwind.config.*']);
            const BabelConfigPath = yield (0, _1.getFilePath)(['babel.config.*']);
            const MetroConfigPath = yield (0, _1.getFilePath)(['metro.config.*']);
            const tsConfigPath = yield (0, _1.getFilePath)(['tsconfig.*']);
            const gluestackConfig = {
                tailwind: {
                    config: tailwindConfigPath.length
                        ? tailwindConfigPath
                        : 'tailwind.config.js',
                    css: globalCssPath.length ? globalCssPath : 'global.css',
                },
                app: {
                    entry: entryPath,
                    components: config_1.config.writableComponentsPath,
                },
            };
            const resolvedGluestackConfig = {
                tailwind: {
                    config: tailwindConfigPath.length
                        ? tailwindConfigPath
                        : 'tailwind.config.js',
                    css: globalCssPath.length ? globalCssPath : 'global.css',
                },
                config: {
                    babelConfig: BabelConfigPath.length ? BabelConfigPath : 'babel.config.js',
                    metroConfig: MetroConfigPath.length ? MetroConfigPath : 'metro.config.js',
                    tsConfig: tsConfigPath.length ? tsConfigPath : 'tsconfig.json',
                },
                app: {
                    entry: (0, _1.pathResolver)(entryPath),
                },
            };
            (0, _1.generateConfig)(gluestackConfig);
            const resolvedConfig = yield resolvedReactNativePaths(resolvedGluestackConfig);
            const filesTobeEnsured = [
                resolvedConfig.config.babelConfig,
                resolvedConfig.config.metroConfig,
                resolvedConfig.config.tsConfig,
                resolvedConfig.tailwind.css,
                (0, _1.pathResolver)('nativewind-env.d.ts'),
            ];
            const filesEnsured = yield (0, __1.ensureFilesPromise)(filesTobeEnsured);
            if (permission && filesEnsured) {
                if (permission) {
                    yield initNatiwindRNApp(resolvedConfig, permission);
                }
            }
        });
    }
});
