var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs-extra", "chalk", "os", "path", "@clack/prompts", "../../config", ".."], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAllComponents = exports.componentAdder = void 0;
    const fs_extra_1 = __importDefault(require("fs-extra"));
    const chalk_1 = __importDefault(require("chalk"));
    const os_1 = __importDefault(require("os"));
    const path_1 = require("path");
    const prompts_1 = require("@clack/prompts");
    const config_1 = require("../../config");
    const __1 = require("..");
    Object.defineProperty(exports, "getAllComponents", { enumerable: true, get: function () { return __1.getAllComponents; } });
    const _homeDir = os_1.default.homedir();
    let existingComponentsChecked = false;
    const componentAdder = (_a) => __awaiter(void 0, [_a], void 0, function* ({ addAll = false, componentArgs = [], }) {
        try {
            const res = yield sortComponentsAndHooks(componentArgs);
            let componentsToAdd = res.components;
            let hooksToAdd = res.hooks;
            if (componentsToAdd.length > 0 || addAll) {
                if (!addAll &&
                    (componentsToAdd === null || componentsToAdd === void 0 ? void 0 : componentsToAdd.length) &&
                    !(yield checkIfComponentIsValid(componentsToAdd))) {
                    prompts_1.log.error(chalk_1.default.red(`Invalid names entered. Kindly check and choose a valid component name.`));
                    return;
                }
                console.log(`\n\x1b[1mAdding new component...\x1b[0m\n`);
                let requestedComponents = addAll
                    ? yield (0, __1.getAllComponents)()
                    : componentsToAdd;
                const { hooks } = yield (0, __1.checkComponentDependencies)(requestedComponents);
                hooksToAdd = Array.from(hooks);
                const updatedComponents = !existingComponentsChecked && requestedComponents.length
                    ? yield isComponentInProject(requestedComponents)
                    : requestedComponents;
                const count = updatedComponents.length;
                yield Promise.all(updatedComponents.map((component) => __awaiter(void 0, void 0, void 0, function* () {
                    const targetPath = (0, path_1.join)(__1.projectRootPath, config_1.config.writableComponentsPath, component);
                    yield writeComponent(component, targetPath);
                })))
                    .then(() => __awaiter(void 0, void 0, void 0, function* () {
                    let versionManager = (0, __1.findLockFileType)();
                    if (!versionManager) {
                        versionManager = yield (0, __1.promptVersionManager)();
                    }
                    yield (0, __1.installDependencies)(updatedComponents, versionManager);
                    prompts_1.log.success(`\x1b[32mDone!\x1b[0m Added new \x1b[1mgluestack-ui\x1b[0m ${count === 1 ? 'component' : 'components'} into project`);
                }))
                    .catch((err) => {
                    prompts_1.log.error(`\x1b[31mError : ${err.message}\x1b[0m`);
                });
            }
            if (hooksToAdd.length > 0)
                yield hookAdder(hooksToAdd);
        }
        catch (err) {
            throw new Error(err.message);
        }
    });
    exports.componentAdder = componentAdder;
    const isComponentInProject = (components) => __awaiter(void 0, void 0, void 0, function* () {
        const alreadyExistingComponents = [];
        let componentsToAdd = [];
        for (const component of components) {
            const pathToCheck = (0, path_1.join)(__1.projectRootPath, config_1.config.writableComponentsPath, component, 'index.tsx');
            if (fs_extra_1.default.existsSync(pathToCheck)) {
                alreadyExistingComponents.push(component);
            }
        }
        //confirm about the already existing components
        if (alreadyExistingComponents.length === 1 ||
            alreadyExistingComponents.length > 1) {
            const shouldContinue = yield confirmOverride(alreadyExistingComponents, alreadyExistingComponents.length);
            //code to remove already existing components from the list
            componentsToAdd = shouldContinue
                ? components.filter((component) => !alreadyExistingComponents.includes(component))
                : processTerminate('Installation aborted');
            if (shouldContinue) {
                componentsToAdd = components;
            }
            else {
                componentsToAdd = [];
            }
        }
        else {
            componentsToAdd = components;
        }
        if (componentsToAdd.length === 0)
            prompts_1.log.error('No components to be added');
        existingComponentsChecked = true;
        return componentsToAdd;
    });
    const processTerminate = (message) => {
        prompts_1.log.error(message);
        process.exit(1);
    };
    const checkIfComponentIsValid = (components) => __awaiter(void 0, void 0, void 0, function* () {
        const componentList = yield (0, __1.getAllComponents)();
        if (components.every((component) => componentList.includes(component)))
            return true;
        else
            return false;
    });
    const writeComponent = (component, targetPath) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            yield fs_extra_1.default.ensureDir(targetPath);
            yield fs_extra_1.default.copy((0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, config_1.config.style, component), (0, path_1.join)(targetPath), {
                overwrite: true,
            });
        }
        catch (error) {
            prompts_1.log.error(`\x1b[31mError: ${error.message}\x1b[0m`);
        }
    });
    const confirmOverride = (component, existingCount) => __awaiter(void 0, void 0, void 0, function* () {
        const displayComponent = existingCount === 1 ? component[0] : 'Few';
        const components = existingCount === 1 ? 'component' : 'components';
        const shouldContinue = yield (0, prompts_1.confirm)({
            message: `\x1b[33mWARNING: ${displayComponent[0].toUpperCase() + displayComponent.slice(1)} ${components} already exists. Continuing with the installation may result in component replacement if changes are made. Please commit your changes before proceeding with the installation. Continue?\x1b[0m`,
        });
        return shouldContinue;
    });
    const hookAdder = (requestedHook) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            prompts_1.log.info(`\n\x1b[1mAdding new hook...\x1b[0m\n`);
            yield writeHook(requestedHook);
            prompts_1.log.success(`\x1b[32mDone!\x1b[0m Added new \x1b[1mgluestack-ui\x1b[0m hook into project`);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    });
    const sortComponentsAndHooks = (inputNames) => __awaiter(void 0, void 0, void 0, function* () {
        if (!inputNames || inputNames.length === 0) {
            return { hooks: [], components: [] };
        }
        const hooksPath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.hooksResourcePath);
        const hooksList = fs_extra_1.default
            .readdirSync(hooksPath)
            .map((file) => (0, __1.removeHyphen)((0, path_1.parse)(file).name).toLowerCase());
        const result = inputNames.reduce((acc, name) => {
            const lowercaseName = name.toLowerCase();
            if (hooksList.includes(lowercaseName)) {
                acc.hooks.push(name);
            }
            else {
                acc.components.push(name);
            }
            return acc;
        }, { hooks: [], components: [] });
        return result;
    });
    const hookFileName = (hook) => __awaiter(void 0, void 0, void 0, function* () {
        const hooksList = fs_extra_1.default.readdirSync((0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.hooksResourcePath));
        let fileName = '';
        hooksList.forEach((file) => {
            if ((0, __1.removeHyphen)((0, path_1.parse)(file).name) == hook.toLowerCase()) {
                fileName = (0, path_1.basename)(file);
            }
        });
        return fileName;
    });
    const writeHook = (hooksArray) => __awaiter(void 0, void 0, void 0, function* () {
        for (const hook of hooksArray) {
            const fileName = yield hookFileName(hook);
            const utilsPath = (0, path_1.join)(__1.projectRootPath, config_1.config.writableComponentsPath, 'utils', fileName);
            const sourceFilePath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.hooksResourcePath, fileName);
            if (fs_extra_1.default.existsSync(utilsPath)) {
                const shouldOverride = yield confirmHookOverride(hook);
                if (!shouldOverride) {
                    processTerminate('Installation aborted');
                }
            }
            try {
                yield fs_extra_1.default.ensureFile(utilsPath);
                yield fs_extra_1.default.copy(sourceFilePath, utilsPath);
            }
            catch (error) {
                prompts_1.log.error(`Error adding hook ${hook}: ${error.message}`);
            }
        }
    });
    const confirmHookOverride = (hook) => __awaiter(void 0, void 0, void 0, function* () {
        const shouldContinue = yield (0, prompts_1.confirm)({
            message: `\x1b[33mWARNING: ${hook[0].toUpperCase() + hook.slice(1)} hook already exists. Continuing with the installation may result in hook replacement if changes are made. Please commit your changes before proceeding with the installation. Continue?\x1b[0m`,
        });
        return shouldContinue;
    });
});
